<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choplifter HD</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BFHFDEFX4Y"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-BFHFDEFX4Y');
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
        }

        #game-container {
            position: relative;
            width: 1920px;
            height: 1080px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            text-shadow: 0 0 10px #0ff;
        }

        .hud-bottom {
            display: flex;
            justify-content: center;
            font-size: 18px;
            opacity: 0.8;
        }

        #start-screen,
        #selection-screen,
        #game-over-screen,
        #level-screen,
        #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 80px;
            margin: 0 0 20px 0;
            background: linear-gradient(to bottom, #fff, #888);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }

        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #c00, #800);
            border: none;
            color: white;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(200, 0, 0, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }

        .hidden {
            display: none !important;
        }

        /* Scanline effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="1920" height="1080"></canvas>
        <div class="scanlines"></div>

        <div id="ui-layer">
            <div class="hud-top">
                <div id="score-display">SCORE: 0</div>
                <div id="stage-display">STAGE: 1</div>
                <div id="lives-display">LIVES: 3</div>
            </div>
            <div class="hud-bottom">
                <div id="hostages-display">HOSTAGES: 0 / 6</div>
                <div id="onboard-display" style="margin-left: 20px; color: #0f0;">ONBOARD: 0</div>
            </div>
        </div>

        <div id="start-screen" class="screen">
            <h1>CHOPLIFTER HD</h1>
            <p style="font-size: 20px; color: #aaa; margin-bottom: 40px;">WASD to Fly | SPACE to Shoot | F for
                Fullscreen</p>
            <button class="btn" id="start-btn">SELECT CHOPPER</button>
        </div>

        <div id="selection-screen" class="screen hidden">
            <h1>SELECT CHOPPER</h1>
            <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 30px;">
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <canvas id="preview-md500" width="150" height="100"
                        style="margin-bottom: 10px; background: #444; border-radius: 10px;"></canvas>
                    <button class="btn select-chopper-btn" data-type="BLACK_HAWK">MD-500 Defender</button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <canvas id="preview-chinook" width="150" height="100"
                        style="margin-bottom: 10px; background: #444; border-radius: 10px;"></canvas>
                    <button class="btn select-chopper-btn" data-type="CHINOOK">CH-47 Chinook</button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <canvas id="preview-airwolf" width="150" height="100"
                        style="margin-bottom: 10px; background: #444; border-radius: 10px;"></canvas>
                    <button class="btn select-chopper-btn" data-type="AIRWOLF">Airwolf</button>
                </div>
            </div>
        </div>div>
        <div id="chopper-preview" style="height: 50px; margin-bottom: 20px; margin-top: 40px; color: #0ff;">
            SELECT A HELICOPTER TO DEPLOY
        </div>
    </div>

    <div id="level-screen" class="hidden">
        <h1 id="level-title">MISSION COMPLETE</h1>
        <p style="font-size: 24px; margin-bottom: 30px;">PREPARING NEXT SORTIE...</p>
    </div>

    <div id="victory-screen" class="hidden">
        <h1>VICTORY</h1>
        <p style="font-size: 24px; margin-bottom: 30px;">ALL MISSIONS ACCOMPLISHED</p>
        <p id="vic-score" style="font-size: 24px; margin-bottom: 30px;">FINAL SCORE: 0</p>
        <button class="btn" id="vic-restart-btn">PLAY AGAIN</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="go-title">MISSION FAILED</h1>
        <p id="go-score" style="font-size: 24px; margin-bottom: 30px;">FINAL SCORE: 0</p>
        <button class="btn" id="restart-btn">RETRY</button>
    </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const CANVAS_WIDTH = 1920;
        const CANVAS_HEIGHT = 1080;
        const GRAVITY = 0.0525; // Reduced by another 30%
        const FRICTION = 0.98;
        const THRUST_POWER = 0.3;
        const ROTATION_SPEED = 0.05;
        const MAX_SPEED = 12;

        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 1.5; // seconds
                this.vy = -1;
                this.markedForDeletion = false;
            }

            update(dt) {
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;
                this.y += this.vy;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.font = '20px Orbitron';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 4;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        // --- INPUT MANAGER ---
        class InputHandler {
            constructor() {
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);

                // Fullscreen toggle
                window.addEventListener('keydown', e => {
                    if (e.code === 'KeyF') {
                        this.toggleFullscreen();
                    }
                });
            }

            isDown(code) {
                return !!this.keys[code];
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
        }

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.input = new InputHandler();

                this.lastTime = 0;
                this.accumulatedTime = 0;
                this.step = 1 / 60;

                this.state = 'MENU';
                this.stage = 1;
                this.score = 0;
                this.lives = 3;
                this.helicopterType = 'BLACK_HAWK';
                this.timeScale = 1.0;

                this.entities = [];
                this.particles = [];
                this.floatingTexts = [];

                // Bind UI
                this.startScreen = document.getElementById('start-screen');
                this.selectionScreen = document.getElementById('selection-screen');
                this.gameOverScreen = document.getElementById('game-over-screen');
                this.levelScreen = document.getElementById('level-screen');
                this.victoryScreen = document.getElementById('victory-screen');

                this.startBtn = document.getElementById('start-btn');
                this.restartBtn = document.getElementById('restart-btn');
                this.vicRestartBtn = document.getElementById('vic-restart-btn');

                this.startBtn.addEventListener('click', () => {
                    this.startScreen.classList.add('hidden');
                    this.selectionScreen.classList.remove('hidden');
                    this.state = 'MENU'; // Ensure menu state for previews
                });

                document.querySelectorAll('.select-chopper-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.helicopterType = e.target.dataset.type;
                        this.selectionScreen.classList.add('hidden');
                        this.startLevel(1);
                    });
                });

                // Return to selection screen on game over / victory restart
                const returnToSelection = () => {
                    this.gameOverScreen.classList.add('hidden');
                    this.victoryScreen.classList.add('hidden');
                    this.selectionScreen.classList.remove('hidden');
                    this.state = 'MENU';
                };

                this.restartBtn.addEventListener('click', returnToSelection);
                this.vicRestartBtn.addEventListener('click', returnToSelection);

                // Resize handler
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize();

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            handleResize() {
                const container = document.getElementById('game-container');
                const aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
                const windowAspect = window.innerWidth / window.innerHeight;

                let scale;
                if (windowAspect < aspect) {
                    scale = window.innerWidth / CANVAS_WIDTH;
                } else {
                    scale = window.innerHeight / CANVAS_HEIGHT;
                }

                container.style.transform = `scale(${scale})`;
            }

            startLevel(level) {
                this.stage = level;
                this.state = 'PLAYING';

                // Reset lives and score if starting fresh
                if (level === 1) {
                    this.lives = 3;
                    this.score = 0;
                }

                this.startScreen.classList.add('hidden');
                this.gameOverScreen.classList.add('hidden');
                this.levelScreen.classList.add('hidden');
                this.victoryScreen.classList.add('hidden');

                // Reset entities
                this.entities = [];
                this.particles = [];
                this.floatingTexts = [];
                this.hostagesRescued = 0;
                this.hostagesTarget = 6; // Fixed goal per level
                this.hostageSpawnTimer = 0;

                // Add Player
                this.player = new Helicopter(this);
                this.player.lastShot = 0;
                this.entities.push(this.player);

                // Generate Level
                // Hostages - Fixed 6 initially
                for (let i = 0; i < 6; i++) {
                    const hx = 2000 + Math.random() * 16000;
                    this.entities.push(new Hostage(this, hx));
                }

                // Enemies - Increase with level
                for (let i = 0; i < 3 + level; i++) {
                    const tx = 1500 + Math.random() * 17000;
                    this.entities.push(new Tank(this, tx));
                }

                // Setup Environment
                this.setupEnvironment(level);

                this.updateUI();
            }

            setupEnvironment(level) {
                // Cycle: Dawn(0), Day(1), Dusk(2), Night(3)
                const cycle = (level - 1) % 4;
                this.timeOfDay = ['DAWN', 'DAY', 'DUSK', 'NIGHT'][cycle];

                // Celestial Body
                this.celestial = {
                    type: (this.timeOfDay === 'NIGHT' || this.timeOfDay === 'DAWN') ? 'MOON' : 'SUN',
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * (CANVAS_HEIGHT / 3),
                    radius: 40 + Math.random() * 40,
                    phase: Math.random(), // For moon
                    color: this.timeOfDay === 'DAWN' ? '#fd5' : '#ff9' // Sun color
                };
            }

            nextLevel() {
                if (this.stage >= 20) {
                    this.victory();
                } else {
                    this.state = 'TRANSITION';
                    this.levelScreen.classList.remove('hidden');
                    setTimeout(() => {
                        this.startLevel(this.stage + 1);
                    }, 3000);
                }
            }

            victory() {
                this.state = 'VICTORY';
                this.victoryScreen.classList.remove('hidden');
                document.getElementById('vic-score').innerText = `FINAL SCORE: ${this.score}`;
            }

            updateUI() {
                document.getElementById('score-display').innerText = `SCORE: ${this.score}`;
                document.getElementById('stage-display').innerText = `STAGE: ${this.stage}`;
                document.getElementById('lives-display').innerText = `LIVES: ${Math.max(0, this.lives - 1)}`;
                document.getElementById('hostages-display').innerText = `HOSTAGES: ${this.hostagesRescued} / ${this.hostagesTarget}`;
                const onboard = this.player ? this.player.passengers : 0;
                document.getElementById('onboard-display').innerText = `ONBOARD: ${onboard}`;
            }

            update(dt) {
                if (this.state !== 'PLAYING') return;

                // Hostage Spawn Logic
                this.hostageSpawnTimer += dt;
                if (this.hostageSpawnTimer >= 60) {
                    this.hostageSpawnTimer = 0;
                    const hx = 2000 + Math.random() * 16000;
                    this.entities.push(new Hostage(this, hx));
                    // Do NOT increase hostagesTarget
                    this.updateUI();
                    this.floatingTexts.push(new FloatingText("REINFORCEMENTS DETECTED!", CANVAS_WIDTH / 2, 200, '#ff0'));
                }

                // Update Entities
                this.entities.forEach(e => e.update(dt));
                this.particles.forEach(p => p.update(dt));
                this.floatingTexts.forEach(t => t.update(dt));

                // Collision Detection
                // Projectiles vs Enemies/Player
                const projectiles = this.entities.filter(e => e instanceof Projectile);
                const targets = this.entities.filter(e => e instanceof Tank || e instanceof Helicopter);

                projectiles.forEach(p => {
                    targets.forEach(t => {
                        if (p.markedForDeletion || t.markedForDeletion) return;
                        if (p.isPlayer && t instanceof Helicopter) return; // No friendly fire
                        if (!p.isPlayer && t instanceof Tank) return; // Enemies don't shoot each other

                        // Simple AABB
                        if (p.x > t.x - t.width / 2 && p.x < t.x + t.width / 2 &&
                            p.y > t.y - t.height / 2 && p.y < t.y + t.height / 2) {

                            p.markedForDeletion = true;

                            // Hit effect
                            this.spawnExplosion(p.x, p.y, 'SMALL');

                            if (t instanceof Tank) {
                                t.markedForDeletion = true;
                                this.spawnExplosion(t.x, t.y, 'BIG');
                                this.score += 100;
                                this.updateUI();
                            } else if (t instanceof Helicopter) {
                                t.markedForDeletion = true;
                                this.spawnExplosion(t.x, t.y, 'BIG');
                                this.lives--;
                                this.updateUI();
                                if (this.lives <= 0) {
                                    this.gameOver();
                                } else {
                                    // Respawn
                                    setTimeout(() => this.respawnPlayer(), 2000);
                                }
                            }
                        }
                    });
                });

                // Cleanup dead entities
                this.entities = this.entities.filter(e => !e.markedForDeletion);
                this.particles = this.particles.filter(p => !p.markedForDeletion);
                this.floatingTexts = this.floatingTexts.filter(t => !t.markedForDeletion);
            }

            spawnExplosion(x, y, type) {
                const count = type === 'BIG' ? 40 : 10;
                const speed = type === 'BIG' ? 8 : 4;
                for (let i = 0; i < count; i++) {
                    const color = Math.random() > 0.5 ? '#f80' : '#ff0';
                    this.particles.push(new Particle(this, x, y, color, Math.random() * speed, Math.random() * 1.0));
                    if (type === 'BIG') {
                        this.particles.push(new Particle(this, x, y, '#444', Math.random() * speed * 0.5, Math.random() * 2.0));
                    }
                }
            }

            respawnPlayer() {
                if (this.lives > 0) {
                    this.player = new Helicopter(this);
                    this.player.lastShot = 0;
                    this.entities.push(this.player);
                }
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.gameOverScreen.classList.remove('hidden');
                document.getElementById('go-score').innerText = `FINAL SCORE: ${this.score}`;
            }

            draw() {
                // Clear Screen
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (this.state === 'PLAYING' || this.state === 'TRANSITION') {
                    // Camera Logic
                    // Target is player x, smoothed
                    if (this.player && !this.player.markedForDeletion) {
                        const targetCamX = -this.player.x + CANVAS_WIDTH / 3;
                        // Clamp camera
                        const minCamX = -(20000 - CANVAS_WIDTH);
                        const maxCamX = 0;
                        // Smooth camera
                        if (!this.camX) this.camX = targetCamX;
                        this.camX += (targetCamX - this.camX) * 0.1;
                        // Clamp
                        if (this.camX > maxCamX) this.camX = maxCamX;
                        if (this.camX < minCamX) this.camX = minCamX;
                    }

                    // --- PARALLAX BACKGROUNDS ---
                    this.drawParallax(this.ctx);

                    // --- WORLD LAYER ---
                    this.ctx.save();
                    this.ctx.translate(this.camX, 0);

                    // Draw Ground
                    this.drawGround(this.ctx);

                    // Draw Entities
                    // Sort by z-index if needed, or just order of arrays
                    // Hostages behind?
                    this.entities.forEach(e => e.draw(this.ctx));
                    this.particles.forEach(p => p.draw(this.ctx));
                    this.floatingTexts.forEach(t => t.draw(this.ctx));

                    this.ctx.restore();
                }
            }

            drawParallax(ctx) {
                // Sky Gradient based on Time of Day
                const skyGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                if (this.timeOfDay === 'DAWN') {
                    skyGrad.addColorStop(0, '#223');
                    skyGrad.addColorStop(0.5, '#644');
                    skyGrad.addColorStop(1, '#d85');
                } else if (this.timeOfDay === 'DAY') {
                    skyGrad.addColorStop(0, '#48c');
                    skyGrad.addColorStop(1, '#adf');
                } else if (this.timeOfDay === 'DUSK') {
                    skyGrad.addColorStop(0, '#214');
                    skyGrad.addColorStop(0.6, '#635');
                    skyGrad.addColorStop(1, '#b62');
                } else { // NIGHT
                    skyGrad.addColorStop(0, '#001');
                    skyGrad.addColorStop(1, '#112');
                }
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Celestial Body
                ctx.save();
                if (this.celestial.type === 'SUN') {
                    // Sun Glow
                    const grad = ctx.createRadialGradient(this.celestial.x, this.celestial.y, 10, this.celestial.x, this.celestial.y, this.celestial.radius * 2);
                    grad.addColorStop(0, this.celestial.color);
                    grad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = grad;
                    ctx.globalCompositeOperation = 'screen';
                    ctx.beginPath();
                    ctx.arc(this.celestial.x, this.celestial.y, this.celestial.radius * 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = this.celestial.color;
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.beginPath();
                    ctx.arc(this.celestial.x, this.celestial.y, this.celestial.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Moon
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(this.celestial.x, this.celestial.y, this.celestial.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Phase mask
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(0,0,0,0.8)'; // Dark shadow
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.beginPath();
                    const phaseOffset = (this.celestial.phase - 0.5) * this.celestial.radius * 2;
                    ctx.arc(this.celestial.x + phaseOffset, this.celestial.y, this.celestial.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                // Stars (only at night/dawn/dusk)
                if (this.timeOfDay !== 'DAY') {
                    ctx.save();
                    ctx.fillStyle = '#FFF';
                    for (let i = 0; i < 100; i++) {
                        const x = (i * 137) % CANVAS_WIDTH;
                        const y = (i * 63) % (CANVAS_HEIGHT / 2);
                        ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                        ctx.fillRect(x, y, 2, 2);
                    }
                    ctx.restore();
                }

                // Mountains - Fix flickering by ensuring positive modulo and wider draw range
                // Colors based on time
                let c1, c2, c3;
                if (this.timeOfDay === 'DAY') { c1 = '#678'; c2 = '#456'; c3 = '#234'; }
                else if (this.timeOfDay === 'NIGHT') { c1 = '#112'; c2 = '#001'; c3 = '#000'; }
                else { c1 = '#324'; c2 = '#213'; c3 = '#102'; }

                this.drawMountainLayer(ctx, this.camX * 0.1, c1, 300, 150);
                this.drawMountainLayer(ctx, this.camX * 0.3, c2, 150, 100);
                this.drawMountainLayer(ctx, this.camX * 0.6, c3, 80, 50);
            }

            drawMountainLayer(ctx, scrollX, color, height, variance) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);

                const patternWidth = 2000;
                // Ensure positive offset for smooth looping
                const offset = ((scrollX % patternWidth) + patternWidth) % patternWidth;

                ctx.lineTo(0, CANVAS_HEIGHT);

                // Draw enough segments to cover screen + buffer
                // Start from -patternWidth to cover left edge when scrolling
                for (let x = -patternWidth; x < CANVAS_WIDTH + patternWidth; x += 50) {
                    const wx = x + (patternWidth - offset); // Shifted x
                    const noise = Math.sin(wx * 0.005) + Math.sin(wx * 0.01) * 0.5;
                    const y = CANVAS_HEIGHT - height + noise * variance;
                    ctx.lineTo(x, y);
                }

                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fill();
            }

            drawGround(ctx) {
                // Ground Pattern
                ctx.fillStyle = '#111';
                ctx.fillRect(0, CANVAS_HEIGHT - 100, 20000, 100);

                // Ground details
                ctx.fillStyle = '#222';
                for (let i = 0; i < 200; i++) {
                    ctx.fillRect(i * 100, CANVAS_HEIGHT - 100, 50, 20);
                }

                // Base (Start)
                ctx.fillStyle = '#334';
                ctx.fillRect(100, CANVAS_HEIGHT - 120, 300, 20);
                // Base Building
                ctx.fillStyle = '#223';
                ctx.fillRect(150, CANVAS_HEIGHT - 180, 100, 60);
                // Flag
                ctx.fillStyle = '#c00';
                ctx.fillRect(200, CANVAS_HEIGHT - 220, 40, 30);
                ctx.fillStyle = '#fff';
                ctx.fillRect(198, CANVAS_HEIGHT - 220, 2, 120);
            }

            loop(timestamp) {
                let dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                // Cap dt to avoid spirals
                if (dt > 0.1) dt = 0.1;

                // Apply Time Scale
                dt *= this.timeScale;

                this.update(dt);
                this.draw();

                if (this.state === 'MENU' && !this.selectionScreen.classList.contains('hidden')) {
                    this.drawSelectionPreviews();
                }

                requestAnimationFrame(this.loop);
            }

            drawSelectionPreviews() {
                if (!this.previewHelis) {
                    this.previewHelis = {
                        'BLACK_HAWK': new Helicopter(this),
                        'CHINOOK': new Helicopter(this),
                        'AIRWOLF': new Helicopter(this)
                    };
                    // Override types for drawing
                    this.previewHelis['BLACK_HAWK'].typeOverride = 'BLACK_HAWK';
                    this.previewHelis['CHINOOK'].typeOverride = 'CHINOOK';
                    this.previewHelis['AIRWOLF'].typeOverride = 'AIRWOLF';
                }

                const types = [
                    { id: 'preview-md500', type: 'BLACK_HAWK' },
                    { id: 'preview-chinook', type: 'CHINOOK' },
                    { id: 'preview-airwolf', type: 'AIRWOLF' }
                ];

                types.forEach(t => {
                    const canvas = document.getElementById(t.id);
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 100);

                    const heli = this.previewHelis[t.type];
                    heli.x = 75;
                    heli.y = 50;
                    heli.rotorFrame += 0.2; // Animate rotors

                    // Scale down slightly to fit
                    ctx.save();
                    ctx.scale(0.6, 0.6);
                    ctx.translate(50, 30); // Center adjustment
                    heli.draw(ctx);
                    ctx.restore();
                });
            }
        }

        // --- ENTITIES ---
        class Entity {
            constructor(game, x, y) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 0;
                this.height = 0;
                this.markedForDeletion = false;
            }
            update(dt) { }
            draw(ctx) { }
        }

        class Helicopter extends Entity {
            constructor(game) {
                super(game, 200, CANVAS_HEIGHT - 300);
                this.width = 120;
                this.height = 60;
                this.angle = 0;
                this.targetAngle = 0;
                this.facingRight = true;
                this.rotorFrame = 0;
                this.passengers = 0;
                this.maxPassengers = 16;
                this.lastShot = 0;
                this.muzzleFlashTimer = 0;

                // Physics Modifiers
                this.gravityMod = 1.0;
                this.thrustMod = 1.0;
                this.speedMod = 1.0;

                const type = this.game.helicopterType || 'BLACK_HAWK';
                if (type === 'CHINOOK') {
                    // Descent rate reduced by 20% (Gravity reduced)
                    this.gravityMod = 0.8;
                    // Horizontal speed reduced by 10%
                    this.speedMod = 0.9;
                } else if (type === 'AIRWOLF') {
                    // Descent rate increased by 10% (Gravity increased)
                    this.gravityMod = 1.1;
                    // Horizontal speed reduced by 25%
                    this.speedMod = 0.75;
                }
            }

            update(dt) {
                const input = this.game.input;

                // Controls
                if (input.isDown('KeyW')) {
                    this.vy -= THRUST_POWER * this.thrustMod;
                }
                // Gravity
                this.vy += GRAVITY * this.gravityMod;

                // Horizontal movement based on tilt
                const accel = 0.2 * this.speedMod;
                if (input.isDown('KeyA')) {
                    this.targetAngle = -0.3;
                    this.facingRight = false;
                    this.vx -= accel;
                } else if (input.isDown('KeyD')) {
                    this.targetAngle = 0.3;
                    this.facingRight = true;
                    this.vx += accel;
                } else {
                    this.targetAngle = 0;
                }

                // Smooth rotation
                this.angle += (this.targetAngle - this.angle) * 0.1;

                // Friction
                this.vx *= FRICTION;
                this.vy *= 0.99; // Air resistance

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Ground Collision
                if (this.y > CANVAS_HEIGHT - 100 - this.height / 2) {
                    // Check crash velocity
                    if (this.vy > 4.0) {
                        // Crash
                        this.markedForDeletion = true;
                        this.game.spawnExplosion(this.x, this.y, 'BIG');
                        this.game.lives--;
                        this.passengers = 0; // Reset onboard
                        this.game.updateUI();
                        if (this.game.lives <= 0) {
                            // Slow Motion Death
                            this.game.timeScale = 0.25;
                            setTimeout(() => {
                                this.game.gameOver();
                                this.game.timeScale = 1.0;
                            }, 4000);
                        } else {
                            setTimeout(() => this.game.respawnPlayer(), 2000);
                        }
                    } else {
                        // Safe landing
                        this.y = CANVAS_HEIGHT - 100 - this.height / 2;
                        this.vy = 0;
                        this.vx *= 0.8; // Ground friction
                        this.angle = 0;
                    }
                }

                // Ceiling Collision
                if (this.y < 50) {
                    this.y = 50;
                    this.vy = 0;
                }

                this.rotorFrame += 0.5;
                if (this.muzzleFlashTimer > 0) this.muzzleFlashTimer -= dt;

                // Shooting
                if (input.isDown('Space') && this.game.lastTime - this.lastShot > 200) {
                    this.shoot();
                    this.lastShot = this.game.lastTime;
                }

                // Unload Passengers
                if (this.x < 400 && this.y > CANVAS_HEIGHT - 150 && this.passengers > 0) {
                    if (!this.unloadTimer) this.unloadTimer = 0;
                    this.unloadTimer += dt;
                    if (this.unloadTimer > 0.2) {
                        this.passengers--;
                        this.game.score += 50;
                        this.game.hostagesRescued++;
                        this.game.updateUI();
                        this.unloadTimer = 0;

                        // Check Level Complete
                        if (this.game.hostagesRescued >= this.game.hostagesTarget) {
                            this.game.nextLevel();
                        }
                    }
                }
            }

            shoot() {
                const offX = this.facingRight ? 40 : -40;
                const angle = this.facingRight ? 0.1 : Math.PI - 0.1;
                const p = new Projectile(this.game, this.x + offX, this.y + 10, angle, true);
                p.vx += this.vx;
                this.game.entities.push(p);
                this.muzzleFlashTimer = 0.05;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 10;

                const type = this.typeOverride || this.game.helicopterType || 'BLACK_HAWK';

                if (type === 'CHINOOK') {
                    // --- CHINOOK (Tandem Rotors, Long Body) ---
                    ctx.fillStyle = '#564';
                    // Body
                    ctx.beginPath();
                    ctx.moveTo(-60, -15);
                    ctx.lineTo(60, -15);
                    ctx.lineTo(70, 0);
                    ctx.lineTo(60, 20);
                    ctx.lineTo(-60, 20);
                    ctx.lineTo(-70, 0);
                    ctx.fill();

                    // Windows
                    ctx.fillStyle = '#8ce';
                    ctx.beginPath();
                    ctx.arc(60, 0, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Rotors (Front and Back) - 35% smaller total (was 15%, now another 20%)
                    this.drawRotor(ctx, -50, -25, 0.65);
                    this.drawRotor(ctx, 50, -25, 0.65);

                    // Wheels
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(-40, 25, 6, 0, Math.PI * 2);
                    ctx.arc(40, 25, 6, 0, Math.PI * 2);
                    ctx.fill();

                } else if (type === 'AIRWOLF') {
                    // --- AIRWOLF (Sleek, Black/White) ---
                    // Compressed Height (75%)
                    ctx.save();
                    ctx.scale(1, 0.75);

                    // Top Black
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    if (this.facingRight) {
                        ctx.moveTo(-40, -10);
                        ctx.lineTo(30, -10);
                        ctx.lineTo(50, 10);
                        ctx.lineTo(-30, 10);
                    } else {
                        ctx.moveTo(40, -10);
                        ctx.lineTo(-30, -10);
                        ctx.lineTo(-50, 10);
                        ctx.lineTo(30, 10);
                    }
                    ctx.fill();

                    // Bottom White
                    ctx.fillStyle = '#eee';
                    ctx.beginPath();
                    if (this.facingRight) {
                        ctx.moveTo(-30, 10);
                        ctx.lineTo(50, 10);
                        ctx.lineTo(40, 25);
                        ctx.lineTo(-20, 25);
                    } else {
                        ctx.moveTo(30, 10);
                        ctx.lineTo(-50, 10);
                        ctx.lineTo(-40, 25);
                        ctx.lineTo(20, 25);
                    }
                    ctx.fill();

                    // Glass
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    if (this.facingRight) {
                        ctx.moveTo(10, -5);
                        ctx.lineTo(30, -5);
                        ctx.lineTo(40, 5);
                        ctx.lineTo(10, 5);
                    } else {
                        ctx.moveTo(-10, -5);
                        ctx.lineTo(-30, -5);
                        ctx.lineTo(-40, 5);
                        ctx.lineTo(-10, 5);
                    }
                    ctx.fill();

                    // Tail (Streamlined)
                    ctx.fillStyle = '#222';
                    if (this.facingRight) {
                        ctx.beginPath();
                        ctx.moveTo(-30, 0); // Connect to body
                        ctx.quadraticCurveTo(-60, 0, -80, -10); // Smooth curve
                        ctx.lineTo(-85, -25);
                        ctx.lineTo(-70, -10);
                        ctx.lineTo(-40, 5);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(30, 0);
                        ctx.quadraticCurveTo(60, 0, 80, -10);
                        ctx.lineTo(85, -25);
                        ctx.lineTo(70, -10);
                        ctx.lineTo(40, 5);
                        ctx.fill();
                    }

                    ctx.restore(); // End compression

                    // Main Rotor (Outside scale)
                    this.drawRotor(ctx, 0, -20);

                } else {
                    // --- BLACK HAWK (Standard) ---
                    const bodyGrad = ctx.createLinearGradient(-40, -20, 40, 20);
                    bodyGrad.addColorStop(0, '#343');
                    bodyGrad.addColorStop(0.5, '#565');
                    bodyGrad.addColorStop(1, '#232');

                    ctx.fillStyle = bodyGrad;
                    // Cockpit shape
                    ctx.beginPath();
                    if (this.facingRight) {
                        ctx.moveTo(-40, -10);
                        ctx.lineTo(20, -10);
                        ctx.bezierCurveTo(50, -10, 50, 20, 20, 20);
                        ctx.lineTo(-30, 20);
                        ctx.lineTo(-40, 10);
                    } else {
                        ctx.moveTo(40, -10);
                        ctx.lineTo(-20, -10);
                        ctx.bezierCurveTo(-50, -10, -50, 20, -20, 20);
                        ctx.lineTo(30, 20);
                        ctx.lineTo(40, 10);
                    }
                    ctx.fill();

                    // Cockpit Glass
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
                    ctx.beginPath();
                    if (this.facingRight) {
                        ctx.moveTo(0, -5);
                        ctx.lineTo(20, -5);
                        ctx.bezierCurveTo(35, -5, 35, 15, 20, 15);
                        ctx.lineTo(0, 15);
                    } else {
                        ctx.moveTo(0, -5);
                        ctx.lineTo(-20, -5);
                        ctx.bezierCurveTo(-35, -5, -35, 15, -20, 15);
                        ctx.lineTo(0, 15);
                    }
                    ctx.fill();

                    // Tail
                    ctx.fillStyle = '#343';
                    if (this.facingRight) {
                        ctx.fillRect(-70, 0, 40, 10);
                        ctx.fillRect(-75, -15, 10, 25);
                    } else {
                        ctx.fillRect(30, 0, 40, 10);
                        ctx.fillRect(65, -15, 10, 25);
                    }

                    // Main Rotor
                    this.drawRotor(ctx, 0, -15);

                    // Skids
                    ctx.strokeStyle = '#111';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-20, 20);
                    ctx.lineTo(-20, 28);
                    ctx.lineTo(20, 28);
                    ctx.lineTo(20, 20);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-30, 28);
                    ctx.lineTo(30, 28);
                    ctx.stroke();
                }

                // Muzzle Flash
                if (this.muzzleFlashTimer > 0) {
                    ctx.fillStyle = '#ff9';
                    ctx.beginPath();
                    const mx = this.facingRight ? 45 : -45;
                    ctx.arc(mx, 10, 10 + Math.random() * 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            drawRotor(ctx, x, y, scale = 1.0) {
                ctx.save();
                ctx.translate(x, y);
                const rotorWidth = 140 * scale;
                const rotorHeight = 4;
                ctx.fillStyle = `rgba(0,0,0, ${0.3 + Math.sin(this.rotorFrame) * 0.2})`;
                ctx.fillRect(-rotorWidth / 2, -rotorHeight / 2, rotorWidth, rotorHeight);
                ctx.fillStyle = `rgba(0,0,0, ${0.3 + Math.cos(this.rotorFrame) * 0.2})`;
                ctx.fillRect(-rotorWidth / 2 * 0.8, -rotorHeight / 2, rotorWidth * 0.8, rotorHeight);
                ctx.restore();
            }
        }

        class Hostage extends Entity {
            constructor(game, x) {
                super(game, x, CANVAS_HEIGHT - 130);
                this.width = 20;
                this.height = 30;
                this.state = 'WAITING';
                this.timer = 0;
                this.speed = 2;
                this.facingRight = true;
                this.boardedProcessed = false;
            }

            update(dt) {
                this.timer += dt;

                const distToPlayer = Math.abs(this.game.player.x - this.x);
                const playerLanded = this.game.player.y > CANVAS_HEIGHT - 150;

                if (this.state === 'WAITING') {
                    if (distToPlayer < 400 && playerLanded) {
                        this.state = 'WAVING';
                    }
                } else if (this.state === 'WAVING') {
                    if (!playerLanded) this.state = 'WAITING';
                    if (distToPlayer < 50 && playerLanded) {
                        this.state = 'BOARDING';
                        this.timer = 0;
                    } else if (distToPlayer > 50 && playerLanded) {
                        this.state = 'FOLLOWING';
                    }
                } else if (this.state === 'FOLLOWING') {
                    if (!playerLanded) {
                        this.state = 'WAITING';
                    } else {
                        if (this.game.player.x > this.x) {
                            this.x += this.speed;
                            this.facingRight = true;
                        } else {
                            this.x -= this.speed;
                            this.facingRight = false;
                        }

                        if (distToPlayer < 30) {
                            this.state = 'BOARDING';
                            this.timer = 0;
                        }
                    }
                } else if (this.state === 'BOARDING') {
                    if (this.timer > 1.0 && !this.boardedProcessed) {
                        this.boardedProcessed = true;
                        if (this.game.player.passengers < this.game.player.maxPassengers) {
                            this.game.player.passengers++;
                            this.markedForDeletion = true;
                            this.game.updateUI();
                            // Boarding Animation
                            this.game.floatingTexts.push(new FloatingText("SAVED!", this.x, this.y - 40, '#0f0'));
                        } else {
                            this.state = 'WAITING';
                            this.boardedProcessed = false;
                            this.game.floatingTexts.push(new FloatingText("FULL!", this.x, this.y - 40, '#f00'));
                        }
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs Animation
                if (this.state === 'FOLLOWING') {
                    const legOffset = Math.sin(this.timer * 15) * 5;
                    ctx.strokeStyle = '#336';
                    ctx.lineWidth = 3;

                    // Left Leg
                    ctx.beginPath();
                    ctx.moveTo(-2, -10);
                    ctx.lineTo(-2 - legOffset, 0);
                    ctx.stroke();

                    // Right Leg
                    ctx.beginPath();
                    ctx.moveTo(2, -10);
                    ctx.lineTo(2 + legOffset, 0);
                    ctx.stroke();
                } else {
                    // Standing
                    ctx.fillStyle = '#336';
                    ctx.fillRect(-5, -10, 10, 10);
                }

                // Body
                ctx.fillStyle = '#ccf';
                ctx.fillRect(-5, -25, 10, 15);

                // Head
                ctx.fillStyle = '#fcc';
                ctx.beginPath();
                ctx.arc(0, -30, 5, 0, Math.PI * 2);
                ctx.fill();

                if (this.state === 'WAVING') {
                    ctx.strokeStyle = '#fcc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-5, -25);
                    const wave = Math.sin(this.timer * 10) * 10;
                    ctx.lineTo(-10, -35 + wave);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(5, -25);
                    ctx.lineTo(10, -35 - wave);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Tank extends Entity {
            constructor(game, x) {
                super(game, x, CANVAS_HEIGHT - 140);
                this.width = 80;
                this.height = 40;
                this.turretAngle = 0;
                this.cooldown = 0;
                this.muzzleFlashTimer = 0;
            }

            update(dt) {
                if (this.cooldown > 0) this.cooldown -= dt;
                if (this.muzzleFlashTimer > 0) this.muzzleFlashTimer -= dt;

                const dx = this.game.player.x - this.x;
                const dy = (this.game.player.y) - (this.y - 20);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 1000) {
                    const targetAngle = Math.atan2(dy, dx);
                    this.turretAngle = targetAngle;

                    if (this.cooldown <= 0 && Math.abs(dx) < 800) {
                        this.shoot();
                        this.cooldown = 2 + Math.random() * 2;
                    }
                }
            }

            shoot() {
                const muzzleX = this.x + Math.cos(this.turretAngle) * 40;
                const muzzleY = (this.y - 20) + Math.sin(this.turretAngle) * 40;

                this.game.entities.push(new Projectile(this.game, muzzleX, muzzleY, this.turretAngle, false));
                this.muzzleFlashTimer = 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = '#454';
                ctx.fillRect(-40, -20, 80, 20);

                ctx.fillStyle = '#222';
                ctx.fillRect(-38, 0, 76, 10);
                ctx.fillStyle = '#555';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(-25 + i * 18, 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.save();
                ctx.translate(0, -20);
                ctx.rotate(this.turretAngle);
                ctx.fillStyle = '#343';
                ctx.fillRect(0, -5, 40, 10);
                ctx.fillStyle = '#454';
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();

                // Muzzle Flash
                if (this.muzzleFlashTimer > 0) {
                    ctx.fillStyle = '#fa0';
                    ctx.beginPath();
                    ctx.arc(45, 0, 15 + Math.random() * 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();

                ctx.restore();
            }
        }

        class Projectile extends Entity {
            constructor(game, x, y, angle, isPlayer) {
                super(game, x, y);
                this.vx = Math.cos(angle) * 15;
                this.vy = Math.sin(angle) * 15;
                this.isPlayer = isPlayer;
                this.life = 2.0;
                this.width = 5;
                this.height = 5;
            }

            update(dt) {
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;

                this.x += this.vx;
                this.y += this.vy;

                if (this.y > CANVAS_HEIGHT - 100) {
                    this.markedForDeletion = true;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.isPlayer ? '#ff0' : '#f80';
                ctx.shadowColor = this.isPlayer ? '#ff0' : '#f00';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Particle extends Entity {
            constructor(game, x, y, color, speed, life) {
                super(game, x, y);
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 5 + 2;
            }

            update(dt) {
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;

                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.05;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.translate(this.x, this.y);
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        // --- INIT ---
        window.onload = () => {
            const game = new Game();
        };

    </script>
</body>

</html>